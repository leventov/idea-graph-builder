[{"py/object": "chunking.Chunk", "chunk": "Chunking Strategies for LLM Applications\nIn the context of building LLM-related applications, chunking is the process of breaking down large pieces of text into smaller segments. It\u2019s an essential technique that helps optimize the relevance of the content we get back from a vector database once we use the LLM to embed content. In this blog post, we\u2019ll explore if and how it helps improve efficiency and accuracy in LLM-related applications.\nAs we know, any content that we index in Pinecone needs to be embedded first. The main reason for chunking is to ensure we\u2019re embedding a piece of content with as little noise as possible that is still semantically relevant.\nFor example, in semantic search, we index a corpus of documents, with each document containing valuable information on a specific topic. By applying an effective chunking strategy, we can ensure our search results accurately capture the essence of the user\u2019s query. If our chunks are too small or too large, it may lead to imprecise search results or missed opportunities to surface relevant content. As a rule of thumb, if the chunk of text makes sense without the surrounding context to a human, it will make sense to the language model as well. Therefore, finding the optimal chunk size for the documents in the corpus is crucial to ensuring that the search results are accurate and relevant.", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 0}, {"py/object": "chunking.Chunk", "chunk": "For example, in semantic search, we index a corpus of documents, with each document containing valuable information on a specific topic. By applying an effective chunking strategy, we can ensure our search results accurately capture the essence of the user\u2019s query. If our chunks are too small or too large, it may lead to imprecise search results or missed opportunities to surface relevant content. As a rule of thumb, if the chunk of text makes sense without the surrounding context to a human, it will make sense to the language model as well. Therefore, finding the optimal chunk size for the documents in the corpus is crucial to ensuring that the search results are accurate and relevant.\nAnother example is conversational agents (which we covered before using Python and Javascript). We use the embedded chunks to build the context for the conversational agent based on a knowledge base that grounds the agent in trusted information. In this situation, it\u2019s important to make the right choice about our chunking strategy for two reasons: First, it will determine whether the context is actually relevant to our prompt. Second, it will determine whether or not we\u2019ll be able to fit the retrieved text into the context before sending it to an outside model provider (e.g., OpenAI), given the limitations on the number of tokens we can send for each request. In some cases, like when using GPT-4 with a 32k context window, fitting the chunks might not be an issue. Still, we need to be mindful of when we\u2019re using very big chunks, as this may adversely affect the relevancy of the results we get back from Pinecone.\nIn this post, we\u2019ll explore several chunking methods and discuss the tradeoffs you should think about when choosing a chunking size and method. Finally, we\u2019ll give some recommendations for determining the best chunk size and method that will be appropriate for your application.\nEmbedding short and long content", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 1}, {"py/object": "chunking.Chunk", "chunk": "Embedding short and long content\nWhen we embed our content, we can anticipate distinct behaviors depending on whether the content is short (like sentences) or long (like paragraphs or entire documents).\nWhen a sentence is embedded, the resulting vector focuses on the sentence\u2019s specific meaning. The comparison would naturally be done on that level when compared to other sentence embeddings. This also implies that the embedding may miss out on broader contextual information found in a paragraph or document.\nWhen a full paragraph or document is embedded, the embedding process considers both the overall context and the relationships between the sentences and phrases within the text. This can result in a more comprehensive vector representation that captures the broader meaning and themes of the text. Larger input text sizes, on the other hand, may introduce noise or dilute the significance of individual sentences or phrases, making finding precise matches when querying the index more difficult.\nThe length of the query also influences how the embeddings relate to one another. A shorter query, such as a single sentence or phrase, will concentrate on specifics and may be better suited for matching against sentence-level embeddings. A longer query that spans more than one sentence or a paragraph may be more in tune with embeddings at the paragraph or document level because it is likely looking for broader context or themes.", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 2}, {"py/object": "chunking.Chunk", "chunk": "The length of the query also influences how the embeddings relate to one another. A shorter query, such as a single sentence or phrase, will concentrate on specifics and may be better suited for matching against sentence-level embeddings. A longer query that spans more than one sentence or a paragraph may be more in tune with embeddings at the paragraph or document level because it is likely looking for broader context or themes.\nThe index may also be non-homogeneous and contain embeddings for chunks of varying sizes. This may pose challenges in terms of query result relevance, but it may also have some positive consequences. On the one hand, the relevance of the query result may fluctuate because of discrepancies between the semantic representations of long and short content. On the other, a non-homogeneous index could potentially capture a wider range of context and information since different chunk sizes represent different levels of granularity in the text. This could accommodate different types of queries more flexibly.\nChunking Considerations\nSeveral variables play a role in determining the best chunking strategy, and these variables vary depending on the use case. Here are some key aspects to keep in mind:", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 3}, {"py/object": "chunking.Chunk", "chunk": "Several variables play a role in determining the best chunking strategy, and these variables vary depending on the use case. Here are some key aspects to keep in mind:\nWhat is the nature of the content being indexed? Are you working with long documents, such as articles or books, or shorter content, like tweets or instant messages? The answer would dictate both which model would be more suitable for your goal and, consequently, what chunking strategy to apply.\nWhich embedding model are you using, and what chunk sizes does it perform optimally on? For instance, sentence-transformer models work well on individual sentences, but a model like text-embedding-ada-002 performs better on chunks containing 256 or 512 tokens.\nWhat are your expectations for the length and complexity of user queries? Will they be short and specific or long and complex? This may inform the way you choose to chunk your content as well so that there\u2019s a closer correlation between the embedded query and embedded chunks.\nHow will the retrieved results be utilized within your specific application? For example, will they be used for semantic search, question answering, summarization, or other purposes? For example, if your results need to be fed into another LLM with a token limit, you\u2019ll have to take that into consideration and limit the size of the chunks based on the number of chunks you\u2019d like to fit into the request to the LLM.\nAnswering these questions will allow you to develop a chunking strategy that balances performance and accuracy, and this, in turn, will ensure the query results are more relevant.\nChunking methods\nThere are different methods for chunking, and each of them might be appropriate for different situations. By examining the strengths and weaknesses of each method, our goal is to identify the right scenario to apply them to.\nFixed-size chunking", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 4}, {"py/object": "chunking.Chunk", "chunk": "Fixed-size chunking\nThis is the most common and straightforward approach to chunking: we simply decide the number of tokens in our chunk and, optionally, whether there should be any overlap between them. In general, we will want to keep some overlap between chunks to make sure that the semantic context doesn\u2019t get lost between chunks. Fixed-sized chunking will be the best path in most common cases. Compared to other forms of chunking, fixed-sized chunking is computationally cheap and simple to use since it doesn\u2019t require the use of any NLP libraries.\nHere\u2019s an example for performing fixed-sized chunking with LangChain:\ntext = \"...\" # your text from langchain.text_splitter import CharacterTextSplitter text_splitter = CharacterTextSplitter( separator = \"\\n\\n\", chunk_size = 256, chunk_overlap = 20 ) docs = text_splitter.create_documents([text])\n\u201cContent-aware\u201d Chunking\nThese are a set of methods for taking advantage of the nature of the content we\u2019re chunking and applying more sophisticated chunking to it. Here are some examples:\nSentence splitting\nAs we mentioned before, many models are optimized for embedding sentence-level content. Naturally, we would use sentence chunking, and there are several approaches and tools available to do this, including:\nNaive splitting: The most naive approach would be to split sentences by periods (\u201c.\u201d) and new lines. While this may be fast and simple, this approach would not take into account all possible edge cases. Here\u2019s a very simple example:\ntext = \"...\" # your text docs = text.split(\".\")\nNLTK: The Natural Language Toolkit (NLTK) is a popular Python library for working with human language data. It provides a sentence tokenizer that can split the text into sentences, helping to create more meaningful chunks. For example, to use NLTK with LangChain, you can do the following:\ntext = \"...\" # your text from langchain.text_splitter import NLTKTextSplitter text_splitter = NLTKTextSplitter() docs = text_splitter.split_text(text)", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 5}, {"py/object": "chunking.Chunk", "chunk": "text = \"...\" # your text from langchain.text_splitter import NLTKTextSplitter text_splitter = NLTKTextSplitter() docs = text_splitter.split_text(text)\nspaCy: spaCy is another powerful Python library for NLP tasks. It offers a sophisticated sentence segmentation feature that can efficiently divide the text into separate sentences, enabling better context preservation in the resulting chunks. For example, to use spaCy with LangChain, you can do the following:\ntext = \"...\" # your text from langchain.text_splitter import SpacyTextSplitter text_splitter = SpaCyTextSplitter() docs = text_splitter.split_text(text)\nRecursive Chunking\nRecursive chunking divides the input text into smaller chunks in a hierarchical and iterative manner using a set of separators. If the initial attempt at splitting the text doesn\u2019t produce chunks of the desired size or structure, the method recursively calls itself on the resulting chunks with a different separator or criterion until the desired chunk size or structure is achieved. This means that while the chunks aren\u2019t going to be exactly the same size, they\u2019ll still \u201caspire\u201d to be of a similar size.\nHere\u2019s an example of how to use recursive chunking with LangChain:\ntext = \"...\" # your text from langchain.text_splitter import RecursiveCharacterTextSplitter text_splitter = RecursiveCharacterTextSplitter( # Set a really small chunk size, just to show. chunk_size = 256, chunk_overlap = 20 ) docs = text_splitter.create_documents([text])\nSpecialized chunking\nMarkdown and LaTeX are two examples of structured and formatted content you might run into. In these cases, you can use specialized chunking methods to preserve the original structure of the content during the chunking process.", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 6}, {"py/object": "chunking.Chunk", "chunk": "Markdown and LaTeX are two examples of structured and formatted content you might run into. In these cases, you can use specialized chunking methods to preserve the original structure of the content during the chunking process.\nMarkdown: Markdown is a lightweight markup language commonly used for formatting text. By recognizing the Markdown syntax (e.g., headings, lists, and code blocks), you can intelligently divide the content based on its structure and hierarchy, resulting in more semantically coherent chunks. For example:\nfrom langchain.text_splitter import MarkdownTextSplitter markdown_text = \"...\" markdown_splitter = MarkdownTextSplitter(chunk_size=100, chunk_overlap=0) docs = markdown_splitter.create_documents([markdown_text])\nLaTex: LaTeX is a document preparation system and markup language often used for academic papers and technical documents. By parsing the LaTeX commands and environments, you can create chunks that respect the logical organization of the content (e.g., sections, subsections, and equations), leading to more accurate and contextually relevant results. For example:\nfrom langchain.text_splitter import LatexTextSplitter latex_text = \"...\" latex_splitter = LatexTextSplitter(chunk_size=100, chunk_overlap=0) docs = latex_splitter.create_documents([latex_text])\nFiguring out the best chunk size for your application\nHere are some pointers to help you come up with an optimal chunk size if the common chunking approaches, like fixed chunking, don\u2019t easily apply to your use case.", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 7}, {"py/object": "chunking.Chunk", "chunk": "Here are some pointers to help you come up with an optimal chunk size if the common chunking approaches, like fixed chunking, don\u2019t easily apply to your use case.\nPreprocessing your Data - You need to first pre-process your data to ensure quality before determining the best chunk size for your application. For example, if your data has been retrieved from the web, you might need to remove HTML tags or specific elements that just add noise.\nSelecting a Range of Chunk Sizes - Once your data is preprocessed, the next step is to choose a range of potential chunk sizes to test. As mentioned previously, the choice should take into account the nature of the content (e.g., short messages or lengthy documents), the embedding model you\u2019ll use, and its capabilities (e.g., token limits). The objective is to find a balance between preserving context and maintaining accuracy. Start by exploring a variety of chunk sizes, including smaller chunks (e.g., 128 or 256 tokens) for capturing more granular semantic information and larger chunks (e.g., 512 or 1024 tokens) for retaining more context.\nEvaluating the Performance of Each Chunk Size - In order to test various chunk sizes, you can either use multiple indices or a single index with multiple namespaces. With a representative dataset, create the embeddings for the chunk sizes you want to test and save them in your index (or indices). You can then run a series of queries for which you can evaluate quality, and compare the performance of the various chunk sizes. This is most likely to be an iterative process, where you test different chunk sizes against different queries until you can determine the best-performing chunk size for your content and expected queries.\nConclusion", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 8}, {"py/object": "chunking.Chunk", "chunk": "Conclusion\nChunking your content is pretty simple in most cases - but it could present some challenges when you start wandering off the beaten path. There\u2019s no one-size-fits-all solution to chunking, so what works for one use case may not work for another. Hopefully, this post will help you get a better intuition for how to approach chunking for your application.", "doc_id": "https://www.pinecone.io/learn/chunking-strategies/", "index": 9}]